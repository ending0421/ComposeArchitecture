1: The Special ViewModel mandates the transmission of a Special Error Type, which standardizes business developers to consider business API error cases during the development phase, ensuring they have a plan for error handling. This approach steers them away from always programming for the correct outcome.
2: The declaration of the Special Error Type must be specific to the business exceptions. The BaseRepo prioritizes the handling of common exceptions, while non-common exceptions are transformed by the business layer. If the business layer chooses not to transform them, the Debug build will now crash the app.Log to Sentry under Release build.
3: BaseViewModel stores common Error types. In AppNavHost, each declared Screen, if it needs to display common exception cases, requires CommonErrorDisplayView to wrap the actual Screen and pass in the specific business ViewModel that inherits from BaseViewModel.
4: BaseRepo can be extended to BaseSupportOfflineRepo, which then implements both a repo for network requests and an OfflineRepo to support Offline mode. BaseSupportOfflineRepo includes functionality to monitor network status; upon any change in network status, it automatically switches to using API calls from the OfflineRepo.
5: BaseRepo can serve as the base class for feature repos that do not require Support Offline Model.
6: Through the series of actions above, common errors are all handled by the common part, and the actual business Screen only needs to concern itself with its SpecialViewModel and UI business presentation. No code related to CommonError needs to be written within it.
